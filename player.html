<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LibreTV 播放器</title>
    <link rel="icon" type="image/png" href="https://images.icon-icons.com/38/PNG/512/retrotv_5520.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="css/styles.css">
    <style>
        /* Optimized: Using more specific selectors where appropriate, maintaining original functionality */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--secondary-color, #0f1622); /* Use CSS variable fallback */
            color: var(--text-color, white); /* Use CSS variable fallback */
            overflow-x: hidden; /* Prevent horizontal scroll */
        }
        .player-container {
            width: 100%;
            max-width: 1200px; /* Consider using Tailwind max-w-screen-xl or similar if consistent */
            margin: 0 auto;
        }
        #player {
            width: 100%;
            height: 60vh; /* Video player height */
            background-color: #000; /* Ensure player area has black background */
        }
        .loading-container {
            position: absolute;
            inset: 0; /* Equivalent to top/left/right/bottom: 0 */
            display: flex; /* Use flex initially, will be hidden/shown by JS */
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 0, 0, 0.7);
            color: var(--text-color, white);
            z-index: 100;
            flex-direction: column;
            opacity: 1; /* Start visible, JS will hide if needed */
            transition: opacity 0.3s ease;
        }
        .loading-container[aria-hidden="true"] {
             opacity: 0;
             pointer-events: none;
        }
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--primary-color, white); /* Use CSS variable */
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 10px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .error-container {
            position: absolute;
            inset: 0;
            display: flex; /* Use flex initially */
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 0, 0, 0.7);
            color: var(--text-color, white);
            z-index: 100;
            flex-direction: column;
            text-align: center;
            padding: 1rem;
            opacity: 0; /* Start hidden */
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
         .error-container[aria-hidden="false"] {
             opacity: 1;
             pointer-events: auto;
        }
        .error-icon {
            font-size: 48px;
            margin-bottom: 10px;
            color: #ff3c78; /* Accent color for error */
        }
        /* Style for active episode button - now uses class from styles.css */
        /* .episode-active {
            background-color: #3b82f6 !important;
            border-color: #60a5fa !important;
        } */
        .episode-grid {
            max-height: 30vh;
            overflow-y: auto;
            padding: 1rem 0;
            /* Add scrollbar styling consistent with styles.css */
            scrollbar-width: thin;
            scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
        }
        .episode-grid::-webkit-scrollbar { width: 6px; }
        .episode-grid::-webkit-scrollbar-track { background: var(--scrollbar-track); border-radius: 3px; }
        .episode-grid::-webkit-scrollbar-thumb { background-color: var(--scrollbar-thumb); border-radius: 3px; }

        /* Custom Switch (copied from styles.css for consolidation if needed, or rely on styles.css) */
        /* Ensure toggle-bg and toggle-dot classes are defined in styles.css or here */
        .switch {
            position: relative;
            display: inline-block;
            width: 46px; /* 2.875rem */
            height: 24px; /* 1.5rem */
            flex-shrink: 0; /* Prevent shrinking in flex layouts */
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        /* slider is now toggle-bg */
        /* slider:before is now toggle-dot */
        input:checked + .toggle-bg {
            background-color: var(--primary-color);
        }
        input:checked ~ .toggle-dot {
            transform: translateX(22px); /* Adjust based on sizes */
        }

        /* Shortcut Hint Styles (copied from styles.css) */
        .shortcut-hint {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 1rem 2rem;
            border-radius: 0.5rem;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none; /* Hidden hints should not be interactive */
        }
        .shortcut-hint.show {
            opacity: 1;
        }

        /* Native Fullscreen Handling */
        .player-container:-webkit-full-screen,
        .player-container:fullscreen {
            position: fixed !important; /* Use important to override other styles */
            top: 0 !important; left: 0 !important;
            width: 100vw !important; height: 100vh !important;
            max-width: none !important; /* Remove max-width in fullscreen */
            z-index: 2147483647 !important; /* Max z-index */
            background-color: #000 !important;
            margin: 0 !important;
        }
        .player-container:-webkit-full-screen #player,
        .player-container:fullscreen #player {
            width: 100% !important; height: 100% !important;
        }
         /* Hide other elements when player container is fullscreen */
        body:-webkit-full-screen-ancestor > *:not(.player-container):not(script):not(style),
        body:fullscreen > *:not(.player-container):not(script):not(style) {
            display: none !important;
        }

        /* Position Restore Hint (copied from styles.css) */
         .position-restore-hint {
            position: absolute;
            bottom: 70px; /* Adjust based on actual player controls height */
            left: 50%;
            transform: translateX(-50%) translateY(20px); /* Start below */
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 150; /* Ensure it's above player elements but potentially below custom controls */
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: none;
            white-space: nowrap; /* Prevent wrapping */
        }
        .position-restore-hint.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0); /* Slide up */
        }

        /* Player Controls Lock Styles (copied from styles.css) */
        .player-container.controls-locked .dplayer-controller,
        .player-container.controls-locked .dplayer-mask,
        .player-container.controls-locked .dplayer-bar-wrap,
        .player-container.controls-locked .dplayer-notice, /* Hide notice */
        .player-container.controls-locked .dplayer-setting, /* Hide settings */
        .player-container.controls-locked .dplayer-comment, /* Hide comments if enabled */
        .player-container.controls-locked .dplayer-bezel, /* Hide center play/pause icon */
        .player-container.controls-locked .dplayer-info-panel, /* Hide info panel */
        .player-container.controls-locked .shortcut-hint { /* Hide shortcut hint */
            opacity: 0 !important;
            pointer-events: none !important;
            visibility: hidden !important; /* Ensure complete hiding */
        }
        /* Keep lock toggle visible and interactive */
        .player-container.controls-locked #lockToggle {
            opacity: 1 !important;
            pointer-events: auto !important;
            visibility: visible !important;
        }

    </style>
</head>
<body class="flex flex-col min-h-screen">
    <header class="bg-[#111] p-4 flex justify-between items-center border-b border-[#333] flex-shrink-0">
        <div class="flex items-center">
            <a href="index.html" class="flex items-center" aria-label="返回 LibreTV 首页">
                <svg class="w-8 h-8 mr-2 text-[#00ccff]" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                </svg>
                <h1 class="text-xl font-bold gradient-text">LibreTV</h1>
            </a>
        </div>
        <!-- Ensure title doesn't excessively shrink other elements -->
        <h2 id="videoTitle" class="text-lg md:text-xl font-semibold truncate flex-1 text-center mx-2 px-2" title="当前视频标题"></h2>
        <a href="index.html" class="px-4 py-2 bg-[#222] hover:bg-[#333] border border-[#333] rounded-lg transition-colors whitespace-nowrap flex-shrink-0">
            返回首页
        </a>
    </header>

    <!-- Use flex-grow to make main content fill available space -->
    <main class="container mx-auto px-4 py-4 flex-grow flex flex-col">
        <!-- Video Player Area -->
        <div id="playerContainer" class="player-container relative flex-shrink-0">
            <!-- Relative positioning needed for overlays -->
            <div class="relative aspect-video"> <!-- Maintain aspect ratio -->
                <div id="player" class="absolute inset-0"></div> <!-- Player fills aspect ratio container -->
                <!-- Loading Overlay -->
                <div class="loading-container" id="loading" role="status" aria-hidden="false">
                    <div class="loading-spinner" aria-hidden="true"></div>
                    <div id="loadingText">正在加载视频...</div>
                </div>
                <!-- Error Overlay -->
                <div class="error-container" id="error" role="alert" aria-hidden="true">
                    <div class="error-icon" aria-hidden="true">⚠️</div>
                    <div id="error-message">视频加载失败</div>
                    <div class="mt-2 text-sm text-gray-400">请尝试其他视频源或稍后重试</div>
                </div>
                <!-- Position Restore Hint (added dynamically by JS) -->
            </div>
        </div>

        <!-- Episode Navigation & Controls Container -->
        <div class="player-container mt-4 flex-shrink-0">
            <!-- Navigation Buttons -->
            <div class="flex justify-between items-center">
                <button onclick="playPreviousEpisode()" id="prevButton" class="px-4 py-2 bg-[#222] hover:bg-[#333] border border-[#333] rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center space-x-1" aria-label="上一集" disabled>
                    <svg class="w-5 h-5 inline-block" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                    </svg>
                    <span>上一集</span>
                </button>
                <span class="text-gray-400 text-sm sm:text-base truncate mx-2" id="episodeInfo" title="当前集数/总集数">加载中...</span>
                <button onclick="playNextEpisode()" id="nextButton" class="px-4 py-2 bg-[#222] hover:bg-[#333] border border-[#333] rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center space-x-1" aria-label="下一集" disabled>
                    <span>下一集</span>
                    <svg class="w-5 h-5 inline-block" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                    </svg>
                </button>
            </div>

            <!-- Settings Row: Autoplay, Order, Lock -->
            <div class="flex justify-end items-center mt-4 mb-2 gap-x-3 sm:gap-x-4">
                 <!-- Autoplay Toggle -->
                 <label for="autoplayToggle" class="flex items-center cursor-pointer space-x-2">
                    <span class="text-gray-400 text-sm">自动连播</span>
                    <div class="switch">
                        <input type="checkbox" id="autoplayToggle" class="opacity-0 absolute w-full h-full cursor-pointer z-10 peer">
                        <div class="toggle-bg block bg-[#333] w-10 h-5 rounded-full transition-colors duration-300 ease-in-out peer-checked:bg-blue-500"></div>
                        <div class="toggle-dot absolute w-4 h-4 bg-white rounded-full top-0.5 left-0.5 transition-transform duration-300 ease-in-out peer-checked:translate-x-[22px] shadow-md"></div>
                    </div>
                 </label>
                 <!-- Order Button -->
                 <button onclick="toggleEpisodeOrder()" class="px-3 py-1 bg-gradient-to-r from-indigo-500 via-purple-500 to-pink-500 text-white text-sm font-semibold rounded-full shadow-lg hover:shadow-xl transition-all duration-300 flex items-center justify-center space-x-1.5" aria-label="切换剧集排序">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 transition-transform duration-300" id="orderIcon" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v3.586L7.707 9.293a1 1 0 00-1.414 1.414l3 3a1 1 0 001.414 0l3-3a1 1 0 00-1.414-1.414L11 10.586V7z" clip-rule="evenodd" />
                    </svg>
                    <span id="orderText">倒序排列</span>
                 </button>
                 <!-- Lock Button -->
                 <button id="lockToggle" onclick="toggleControlsLock()" title="锁定/解锁控制" aria-label="锁定控制"
                         class="p-1.5 bg-[#333] hover:bg-[#444] text-white rounded-full transition focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-[#111] focus:ring-white">
                    <svg id="lockIcon" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" aria-hidden="true">
                        <!-- Default state: Unlocked icon -->
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11V7a3 3 0 00-6 0v4m-3 4h12v6H6v-6z" />
                    </svg>
                 </button>
            </div>
        </div>

        <!-- Episode Grid Container -->
        <div class="player-container episode-grid flex-grow min-h-0"> <!-- Allow grid to take remaining space -->
            <div class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-8 xl:grid-cols-10 gap-2" id="episodesList">
                <!-- Episode buttons will be dynamically loaded here -->
                <div class="col-span-full text-center text-gray-400 py-8">加载中...</div>
            </div>
        </div>
    </main>

    <!-- Shortcut Hint Overlay -->
    <div class="shortcut-hint" id="shortcutHint" role="status" aria-live="polite" aria-hidden="true">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" id="shortcutIcon" aria-hidden="true">
            <!-- Icon path updated by JS -->
        </svg>
        <span id="shortcutText"></span>
    </div>

    <!-- External Libraries -->
    <script src="https://s4.zstatic.net/ajax/libs/hls.js/1.5.6/hls.min.js" integrity="sha256-X1GmLMzVcTBRiGjEau+gxGpjRK96atNczcLBg5w6hKA=" crossorigin="anonymous" defer></script>
    <script src="https://s4.zstatic.net/ajax/libs/dplayer/1.26.0/DPlayer.min.js" integrity="sha256-OJg03lDZP0NAcl3waC9OT5jEa8XZ8SM2n081Ik953o4=" crossorigin="anonymous" defer></script>
    <!-- Local Config -->
    <script src="js/config.js" defer></script>
    <!-- Inline Player Logic -->
    <script>
        "use strict"; // Enforce strict mode

        // --- Global Variables ---
        let currentVideoTitle = '';
        let currentEpisodeIndex = 0;
        let currentEpisodes = [];
        let episodesReversed = false;
        let dp = null; // DPlayer instance
        let currentHls = null; // HLS.js instance
        let autoplayEnabled = true;
        let isUserSeeking = false;
        let videoHasEnded = false;
        let userClickedPosition = null; // Tracks precise time from progress bar click/touch
        let shortcutHintTimeout = null;
        let adFilteringEnabled = true; // Default value, read from localStorage
        let progressSaveInterval = null;
        let controlsLocked = false;

        // --- DOM Element Caching ---
        // Cache frequently accessed elements after DOM is loaded
        let loadingElement, errorElement, loadingTextElement, errorMessageElement,
            videoTitleElement, episodeInfoElement, prevButtonElement, nextButtonElement,
            autoplayToggleElement, episodesListElement, orderTextElement, orderIconElement,
            lockToggleButtonElement, lockIconElement, shortcutHintElement, shortcutTextElement,
            shortcutIconElement, playerContainerElement;

        function cacheDOMElements() {
            loadingElement = document.getElementById('loading');
            errorElement = document.getElementById('error');
            loadingTextElement = document.getElementById('loadingText'); // Added ID
            errorMessageElement = document.getElementById('error-message');
            videoTitleElement = document.getElementById('videoTitle');
            episodeInfoElement = document.getElementById('episodeInfo');
            prevButtonElement = document.getElementById('prevButton');
            nextButtonElement = document.getElementById('nextButton');
            autoplayToggleElement = document.getElementById('autoplayToggle');
            episodesListElement = document.getElementById('episodesList');
            orderTextElement = document.getElementById('orderText');
            orderIconElement = document.getElementById('orderIcon');
            lockToggleButtonElement = document.getElementById('lockToggle');
            lockIconElement = document.getElementById('lockIcon');
            shortcutHintElement = document.getElementById('shortcutHint');
            shortcutTextElement = document.getElementById('shortcutText');
            shortcutIconElement = document.getElementById('shortcutIcon');
            playerContainerElement = document.getElementById('playerContainer'); // Cache player container
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', function() {
            cacheDOMElements(); // Cache elements once DOM is ready

            // Parse URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            const videoUrl = urlParams.get('url');
            const title = urlParams.get('title');
            let index = parseInt(urlParams.get('index') || '0', 10); // Ensure base 10
            const episodesListParam = urlParams.get('episodes'); // Use unique name
            const positionParam = urlParams.get('position'); // Use unique name

            // Load state from localStorage
            currentVideoTitle = title || localStorage.getItem('currentVideoTitle') || '未知视频';
            autoplayEnabled = localStorage.getItem(AUTOPLAY_KEY) !== 'false'; // Use constant from config.js
            adFilteringEnabled = localStorage.getItem(PLAYER_CONFIG.adFilteringStorage) !== 'false'; // Use constant
            episodesReversed = localStorage.getItem(EPISODE_REVERSE_KEY) === 'true'; // Use constant

            if (autoplayToggleElement) {
                autoplayToggleElement.checked = autoplayEnabled;
                autoplayToggleElement.addEventListener('change', handleAutoplayToggleChange);
            }

            // Load episodes: Priority URL -> localStorage
            try {
                if (episodesListParam) {
                    currentEpisodes = JSON.parse(decodeURIComponent(episodesListParam));
                    console.log(`Restored ${currentEpisodes.length} episodes from URL parameter.`);
                } else {
                    const storedEpisodes = localStorage.getItem('currentEpisodes');
                    currentEpisodes = storedEpisodes ? JSON.parse(storedEpisodes) : [];
                    console.log(`Restored ${currentEpisodes.length} episodes from localStorage.`);
                }

                // Validate episode index
                if (index < 0 || (currentEpisodes.length > 0 && index >= currentEpisodes.length)) {
                    console.warn(`Invalid episode index ${index} received. Adjusting.`);
                    index = Math.max(0, Math.min(index, currentEpisodes.length - 1));
                    // Update URL silently if adjusted
                    const currentUrl = new URL(window.location.href);
                    if (parseInt(currentUrl.searchParams.get('index') || '0', 10) !== index) {
                        currentUrl.searchParams.set('index', index);
                        window.history.replaceState({}, '', currentUrl);
                    }
                }
                currentEpisodeIndex = index;

            } catch (e) {
                console.error('Failed to load or parse episode data:', e);
                currentEpisodes = [];
                currentEpisodeIndex = 0;
            }

            // Update UI elements
            document.title = currentVideoTitle + ' - LibreTV播放器';
            if (videoTitleElement) videoTitleElement.textContent = currentVideoTitle;
            if (videoTitleElement) videoTitleElement.title = currentVideoTitle; // Add title attribute for full name

            updateEpisodeInfo();
            renderEpisodes();
            updateButtonStates();
            updateOrderButton();

            // Initialize Player
            if (videoUrl) {
                initPlayer(videoUrl);
                // Restore position if provided and valid
                if (positionParam) {
                    const positionNum = parseInt(positionParam, 10);
                    if (!isNaN(positionNum) && positionNum > 0) {
                        // Wait a bit for player to be ready before seeking
                        const seekTimeout = setTimeout(() => {
                            if (dp && dp.video && dp.video.readyState >= 1) { // Check readyState
                                console.log(`Attempting to restore position to ${positionNum}s`);
                                dp.seek(positionNum);
                                dp.notice(`已从 ${formatTime(positionNum)} 继续播放`, 2000);
                                // showPositionRestoreHint(positionNum); // Use dp.notice instead
                            } else {
                                console.warn("Player not ready for seeking, position restore skipped.");
                            }
                        }, 1500);
                        // Ensure timeout is cleared if player initializes later or fails
                         if (dp) dp.on('ready', () => clearTimeout(seekTimeout));
                    }
                }
            } else {
                showError('无效的视频链接');
                if (loadingElement) loadingElement.setAttribute('aria-hidden', 'true');
            }

            // Add global event listeners
            document.addEventListener('keydown', handleKeyboardShortcuts);
            window.addEventListener('beforeunload', saveCurrentProgress);
            document.addEventListener('visibilitychange', handleVisibilityChange);
        });

        // --- Event Handlers ---
        function handleAutoplayToggleChange(e) {
            autoplayEnabled = e.target.checked;
            localStorage.setItem(AUTOPLAY_KEY, autoplayEnabled); // Use constant
        }

        function handleKeyboardShortcuts(e) {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) return;
            if (!dp) return; // Don't process if player not ready

            let preventDefault = false;
            switch (e.key) {
                case ' ': // Space bar - Toggle play/pause
                     if (!controlsLocked) {
                         dp.toggle();
                         preventDefault = true;
                     }
                     break;
                case 'ArrowLeft': // Left Arrow - Rewind
                    if (!controlsLocked) {
                        dp.seek(dp.video.currentTime - (e.altKey ? 1 : 5)); // Alt+Left = Rewind 1s, Left = Rewind 5s
                        dp.notice(`- ${e.altKey ? 1 : 5}s`, 500);
                         if(e.altKey) {
                             if (currentEpisodeIndex > 0) {
                                 playPreviousEpisode();
                                 showShortcutHint('上一集', 'left');
                                 preventDefault = true;
                             }
                         } else {
                            preventDefault = true;
                         }
                    }
                    break;
                case 'ArrowRight': // Right Arrow - Forward
                     if (!controlsLocked) {
                         dp.seek(dp.video.currentTime + (e.altKey ? 1 : 5)); // Alt+Right = Forward 1s, Right = Forward 5s
                         dp.notice(`+ ${e.altKey ? 1 : 5}s`, 500);
                         if (e.altKey) {
                            if (currentEpisodeIndex < currentEpisodes.length - 1) {
                                playNextEpisode();
                                showShortcutHint('下一集', 'right');
                                preventDefault = true;
                            }
                        } else {
                            preventDefault = true;
                        }
                     }
                    break;
                case 'ArrowUp': // Up Arrow - Volume Up
                     if (!controlsLocked) {
                         dp.volume(dp.video.volume + 0.1, true, false);
                         preventDefault = true;
                     }
                    break;
                case 'ArrowDown': // Down Arrow - Volume Down
                     if (!controlsLocked) {
                         dp.volume(dp.video.volume - 0.1, true, false);
                         preventDefault = true;
                     }
                    break;
                case 'f': // F key - Toggle Fullscreen
                     if (!controlsLocked) {
                         dp.fullScreen.toggle();
                         preventDefault = true;
                     }
                    break;
                 case 'l': // L key - Toggle Lock
                     toggleControlsLock();
                     preventDefault = true;
                     break;
                case 'm': // M key - Toggle Mute
                    if (!controlsLocked) {
                        if (dp.video.volume > 0) {
                            dp.volume(0, true, true); // Mute
                        } else {
                            dp.volume(0.7, true, true); // Unmute to default 0.7
                        }
                        preventDefault = true;
                    }
                    break;
            }

            if (preventDefault) {
                e.preventDefault();
            }
        }

        function handleVisibilityChange() {
            if (document.visibilityState === 'hidden') {
                saveCurrentProgress();
            }
        }

        // --- Player Initialization ---
        function initPlayer(videoUrl) {
            if (!videoUrl || !document.getElementById('player')) return;

            // Ensure previous instances are destroyed
            if (dp) {
                console.log("Destroying previous DPlayer instance.");
                saveCurrentProgress(); // Save progress before destroying
                clearInterval(progressSaveInterval);
                 if (dp.video) dp.video.removeEventListener('pause', saveCurrentProgress);
                dp.destroy();
                dp = null;
            }
            if (currentHls) {
                console.log("Destroying previous HLS instance.");
                currentHls.destroy();
                currentHls = null;
            }

            showLoadingUI(); // Show loading indicator

            const hlsConfig = { /* ... HLS config as before ... */
                debug: false,
                loader: adFilteringEnabled ? CustomHlsJsLoader : Hls.DefaultConfig.loader, // Conditional loader
                enableWorker: true, lowLatencyMode: false, backBufferLength: 90,
                maxBufferLength: 30, maxMaxBufferLength: 60, maxBufferSize: 30 * 1000 * 1000,
                maxBufferHole: 0.5, fragLoadingMaxRetry: 6, fragLoadingMaxRetryTimeout: 64000,
                fragLoadingRetryDelay: 1000, manifestLoadingMaxRetry: 3, manifestLoadingRetryDelay: 1000,
                levelLoadingMaxRetry: 4, levelLoadingRetryDelay: 1000, startLevel: -1,
                abrEwmaDefaultEstimate: 500000, abrBandWidthFactor: 0.95, abrBandWidthUpFactor: 0.7,
                abrMaxWithRealBitrate: true, stretchShortVideoTrack: true, appendErrorMaxRetry: 5,
                liveSyncDurationCount: 3, liveDurationInfinity: false
             };

            try {
                dp = new DPlayer({
                    container: document.getElementById('player'),
                    autoplay: true, theme: '#00ccff', preload: 'auto', loop: false, lang: 'zh-cn',
                    hotkey: false, // Disable DPlayer default hotkeys, use custom handler
                    mutex: true, volume: 0.7, screenshot: true, preventClickToggle: false,
                    airplay: true, chromecast: true,
                    contextmenu: [ /* ... context menu as before ... */
                        { text: '关于 LibreTV', link: 'https://github.com/bestzwei/LibreTV' },
                        { text: '问题反馈', click: () => window.open('https://github.com/bestzwei/LibreTV/issues', '_blank') }
                    ],
                    video: {
                        url: videoUrl, type: 'hls', pic: '', // Removed default pic
                        customType: {
                            hls: function(video, player) {
                                // Destroy previous HLS instance if exists
                                if (currentHls) currentHls.destroy();

                                const hls = new Hls(hlsConfig);
                                currentHls = hls;
                                let errorDisplayed = false;
                                let errorCount = 0;
                                let playbackStarted = false;
                                let bufferAppendErrorCount = 0;

                                video.addEventListener('playing', () => {
                                    playbackStarted = true;
                                    hideLoadingUI();
                                    hideErrorUI();
                                });

                                video.addEventListener('timeupdate', () => {
                                     if (video.currentTime > 0.5 && errorElement && errorElement.getAttribute('aria-hidden') === 'false') {
                                         hideErrorUI(); // Hide error if video starts playing
                                     }
                                });

                                hls.loadSource(video.src);
                                hls.attachMedia(video);

                                hls.on(Hls.Events.MANIFEST_PARSED, () => {
                                    video.play().catch(e => console.warn('Autoplay prevented:', e));
                                });

                                hls.on(Hls.Events.ERROR, (event, data) => {
                                    console.warn('HLS Error:', event, data);
                                    errorCount++;

                                     if (data.details === Hls.ErrorDetails.BUFFER_APPEND_ERROR) {
                                        bufferAppendErrorCount++;
                                        if (playbackStarted) return; // Ignore if playing
                                        if (bufferAppendErrorCount >= 3) hls.recoverMediaError();
                                     } else if (data.fatal && !playbackStarted) {
                                         console.error('Fatal HLS Error:', data);
                                         switch(data.type) {
                                             case Hls.ErrorTypes.NETWORK_ERROR:
                                                 if (errorCount <= 3) hls.startLoad(); else showError('网络错误，请检查连接');
                                                 break;
                                             case Hls.ErrorTypes.MEDIA_ERROR:
                                                 if (errorCount <= 3) hls.recoverMediaError(); else showError('媒体错误，视频可能已损坏');
                                                 break;
                                             default:
                                                 if (errorCount > 3 && !errorDisplayed) {
                                                     showError('无法加载视频，请稍后重试');
                                                     errorDisplayed = true;
                                                 }
                                         }
                                     }
                                });

                                hls.on(Hls.Events.FRAG_LOADED, hideLoadingUI);
                                hls.on(Hls.Events.LEVEL_LOADED, hideLoadingUI);

                                // Black screen skip logic (as before)
                                let tmp_time_add = 0.1;
                                const tmp_max_buffer_length = hls.config.maxBufferLength;
                                hls.on(Hls.Events.FRAG_PARSED, (event, data) => {
                                    if (data.frag.endList && hls.media) {
                                        const cur = hls.media.currentTime;
                                        const dur = hls.media.duration || 0;
                                        if (cur < dur - 0.5) { // Check if not already at the very end
                                            data.frag.endList = undefined;
                                            hls.config.maxBufferLength = tmp_time_add < 1 ? 2 : tmp_max_buffer_length;
                                            hls.loadSource(video.src);
                                            hls.attachMedia(hls.media); // Re-attach
                                            hls.media.currentTime = Math.min(dur - 0.1, cur + tmp_time_add); // Ensure stay within duration
                                            tmp_time_add = tmp_time_add < 1 ? 5 : 0.1;
                                            hls.media.play().catch(() => {});
                                        } else {
                                            hls.media.pause(); // Pause if already at end
                                        }
                                    }
                                });

                            } // end hls function
                        } // end customType
                    } // end video object
                }); // end new DPlayer

                // --- DPlayer Event Listeners ---
                dp.on('fullscreen', handleFullscreenEnter);
                dp.on('fullscreen_cancel', handleFullscreenExit);
                dp.on('loadedmetadata', handleLoadedMetadata);
                dp.on('error', handlePlayerError);
                dp.on('seeking', handleSeeking);
                dp.on('seeked', handleSeeked);
                dp.on('ended', handleVideoEnded);
                dp.on('timeupdate', handleTimeUpdate); // Also used for resetting end flag
                dp.on('volumechange', handleVolumeChange); // Optional: save volume

                // Setup precise clicks after a short delay to ensure elements exist
                setTimeout(setupProgressBarPreciseClicks, 500);

                 // Loading timeout check
                 setTimeout(() => {
                    if (loadingElement && loadingElement.getAttribute('aria-hidden') === 'false') {
                        if (loadingTextElement) loadingTextElement.textContent = '加载时间较长，请耐心等待或更换来源...';
                    }
                 }, 10000);


            } catch (playerError) {
                console.error("Failed to initialize DPlayer:", playerError);
                showError("播放器初始化失败");
            }
        }

        // --- DPlayer Event Handlers ---
        function handleFullscreenEnter() {
             if (playerContainerElement && playerContainerElement.requestFullscreen) {
                 playerContainerElement.requestFullscreen().catch(err => console.warn('Request native fullscreen failed:', err));
             } else if (playerContainerElement && playerContainerElement.webkitRequestFullscreen) { // Safari
                 playerContainerElement.webkitRequestFullscreen();
             }
             // Attempt to lock orientation
            if (window.screen.orientation && window.screen.orientation.lock) {
                window.screen.orientation.lock('landscape').catch(err => console.warn('Screen lock failed:', err));
            }
        }

        function handleFullscreenExit() {
            if (document.fullscreenElement && document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitFullscreenElement && document.webkitExitFullscreen) { // Safari
                document.webkitExitFullscreen();
            }
             // Unlock orientation
            if (window.screen.orientation && window.screen.orientation.unlock) {
                window.screen.orientation.unlock();
            }
        }

        function handleLoadedMetadata() {
            hideLoadingUI();
            videoHasEnded = false;
            setupProgressBarPreciseClicks(); // Re-setup on new metadata
            setTimeout(saveToHistory, 3000); // Save after delay
            startProgressSaveInterval();
             // Attach pause listener here, ensuring dp.video exists
             if (dp && dp.video) {
                 dp.video.removeEventListener('pause', saveCurrentProgress); // Remove old if any
                 dp.video.addEventListener('pause', saveCurrentProgress);
             }
        }

        function handlePlayerError() {
            // Ignore error if video is already playing significantly
            if (dp && dp.video && dp.video.currentTime > 1) {
                console.warn("Player error occurred, but video seems to be playing. Ignoring.");
                return;
            }
            showError('视频播放失败，请检查源或网络');
        }

        function handleSeeking() {
            isUserSeeking = true;
            videoHasEnded = false;
            if (userClickedPosition !== null && dp && dp.video) {
                const targetTime = Math.min(userClickedPosition, (dp.video.duration || Infinity) - 0.5); // Prevent seeking exactly to end
                dp.seek(targetTime); // DPlayer's seek method handles setting currentTime
                 console.log(`User seeking to: ${targetTime.toFixed(2)}`);
                userClickedPosition = null; // Reset after seek initiated
            }
        }

        function handleSeeked() {
             // Delay resetting isUserSeeking to differentiate from ended event
            setTimeout(() => { isUserSeeking = false; }, 200);
            // If seeked very close to the end, pull back slightly
            if (dp && dp.video && dp.video.duration > 0) {
                const timeFromEnd = dp.video.duration - dp.video.currentTime;
                 if (timeFromEnd < 0.5) {
                     dp.seek(Math.max(0, dp.video.duration - 1)); // Seek 1s before end
                 }
            }
             saveCurrentProgress(); // Save progress after seeking finishes
        }

        function handleVideoEnded() {
            // Only trigger auto-next if it wasn't due to user seeking near the end
            if (!isUserSeeking) {
                videoHasEnded = true;
                console.log("Video ended naturally.");
                saveCurrentProgress(true); // Mark as finished in save
                clearVideoProgress(); // Clear specific progress key

                if (autoplayEnabled && currentEpisodeIndex < currentEpisodes.length - 1) {
                    console.log("Autoplaying next episode...");
                    // Use timeout to allow other 'ended' handlers to finish
                    setTimeout(playNextEpisode, 500);
                } else {
                    console.log("End of series or autoplay disabled.");
                }
            } else {
                 console.log("Ended event likely triggered by seeking near end, ignoring.");
                 videoHasEnded = false; // Reset end flag if caused by seek
            }
        }

        function handleTimeUpdate() {
             // Reset video ended flag if user seeks back from the end
             if (videoHasEnded && dp && dp.video && dp.video.currentTime < dp.video.duration - 1) {
                 videoHasEnded = false;
             }
             // Throttle progress saving within timeupdate (moved to separate interval)
        }

        function handleVolumeChange() {
            if (dp && dp.video) {
                try {
                    localStorage.setItem('dplayerVolume', dp.video.volume);
                } catch (e) { console.warn("Failed to save volume to localStorage"); }
            }
        }

        // --- UI Update Functions ---
        function showLoadingUI(message = '正在加载视频...') {
            if (!loadingElement) return;
            if (loadingTextElement) loadingTextElement.textContent = message;
            loadingElement.setAttribute('aria-hidden', 'false');
            hideErrorUI(); // Ensure error is hidden when loading
        }

        function hideLoadingUI() {
            if (loadingElement) loadingElement.setAttribute('aria-hidden', 'true');
        }

        function showError(message) {
            if (!errorElement) return;
             // Avoid showing error if video is already playing
             if (dp && dp.video && dp.video.currentTime > 1) {
                 console.warn("Attempted to show error while video is playing, suppressed:", message);
                 return;
             }
            if (errorMessageElement) errorMessageElement.textContent = message;
            errorElement.setAttribute('aria-hidden', 'false');
            hideLoadingUI(); // Hide loading when showing error
        }

        function hideErrorUI() {
            if (errorElement) errorElement.setAttribute('aria-hidden', 'true');
        }

        function updateEpisodeInfo() {
             if (!episodeInfoElement) return;
            if (currentEpisodes.length > 0) {
                episodeInfoElement.textContent = `第 ${currentEpisodeIndex + 1} / ${currentEpisodes.length} 集`;
            } else {
                episodeInfoElement.textContent = '无集数信息';
            }
        }

        function updateButtonStates() {
            if (!prevButtonElement || !nextButtonElement) return;
            prevButtonElement.disabled = currentEpisodeIndex <= 0;
            nextButtonElement.disabled = currentEpisodeIndex >= currentEpisodes.length - 1;
        }

        function renderEpisodes() {
            if (!episodesListElement) return;

            if (!currentEpisodes || currentEpisodes.length === 0) {
                episodesListElement.innerHTML = '<div class="col-span-full text-center text-gray-400 py-8">没有可用的集数</div>';
                return;
            }

            const episodesToRender = episodesReversed ? [...currentEpisodes].reverse() : currentEpisodes;
            const fragment = document.createDocumentFragment(); // Use fragment for performance

            episodesToRender.forEach((episodeUrl, index) => {
                const realIndex = episodesReversed ? currentEpisodes.length - 1 - index : index;
                const isActive = realIndex === currentEpisodeIndex;

                const button = document.createElement('button');
                button.id = `episode-${realIndex}`;
                button.textContent = `第 ${realIndex + 1} 集`;
                 button.className = `px-2 sm:px-4 py-2 border rounded-lg transition-colors text-center text-xs sm:text-sm truncate episode-btn ${
                    isActive ? 'episode-active bg-blue-600 border-blue-500' : 'bg-[#222] hover:bg-[#333] border-[#333]'
                 }`;
                 button.setAttribute('aria-current', isActive ? 'true' : 'false');
                button.onclick = () => playEpisode(realIndex);
                fragment.appendChild(button);
            });

            episodesListElement.innerHTML = ''; // Clear previous content
            episodesListElement.appendChild(fragment);

            // Scroll active episode into view
             setTimeout(() => {
                const activeButton = document.getElementById(`episode-${currentEpisodeIndex}`);
                if (activeButton) {
                    activeButton.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }, 100);
        }

        function updateOrderButton() {
            if (!orderTextElement || !orderIconElement) return;
            orderTextElement.textContent = episodesReversed ? '正序排列' : '倒序排列';
            orderIconElement.style.transform = episodesReversed ? 'rotate(180deg)' : 'rotate(0deg)';
            // Update aria-label? (optional)
        }

        // --- Episode Playback Logic ---
        function playEpisode(index) {
            if (index < 0 || index >= currentEpisodes.length) {
                console.error(`Invalid episode index: ${index}`);
                showToast(`无效的剧集索引: ${index + 1}`);
                return;
            }
             if (index === currentEpisodeIndex && dp && !dp.video.paused) {
                 console.log(`Episode ${index + 1} is already playing.`);
                 return; // Don't restart if already playing the selected episode
             }

            saveCurrentProgress(); // Save progress of the current episode first
            clearInterval(progressSaveInterval); // Stop interval timer for old episode

            showLoadingUI();
            const url = currentEpisodes[index];
            currentEpisodeIndex = index;
            videoHasEnded = false;
            userClickedPosition = null; // Reset seek position

            // Update URL without refresh
            const currentUrl = new URL(window.location.href);
            currentUrl.searchParams.set('index', index);
            currentUrl.searchParams.set('url', url);
             // Preserve source if present
             if (!currentUrl.searchParams.has('source')) {
                const sourceName = localStorage.getItem('lastPlayedSource') || ''; // Try to get last source
                if (sourceName) currentUrl.searchParams.set('source', sourceName);
             }
            window.history.pushState({}, '', currentUrl);

            // Initialize player with new source
             initPlayer(url); // initPlayer now handles cleanup and setup

            // Update UI
            updateEpisodeInfo();
            updateButtonStates();
            renderEpisodes(); // Re-render to update active state
        }

        function playPreviousEpisode() {
            if (currentEpisodeIndex > 0) {
                playEpisode(currentEpisodeIndex - 1);
            }
        }

        function playNextEpisode() {
            if (currentEpisodeIndex < currentEpisodes.length - 1) {
                playEpisode(currentEpisodeIndex + 1);
            }
        }

        function toggleEpisodeOrder() {
            episodesReversed = !episodesReversed;
            localStorage.setItem(EPISODE_REVERSE_KEY, episodesReversed); // Use constant
            renderEpisodes();
            updateOrderButton();
        }

        // --- Progress Bar & Seeking ---
        function setupProgressBarPreciseClicks() {
            // DPlayer handles progress bar clicks internally, custom handling might conflict.
            // Relying on DPlayer's seeking/seeked events and the userClickedPosition logic.
             console.log("Skipping custom progress bar click setup, relying on DPlayer events.");
             // If precise seeking is still an issue, re-introduce careful event handling on '.dplayer-bar-wrap'
        }

        // --- History & Progress Saving ---
        function saveToHistory() {
            if (!currentEpisodes || currentEpisodes.length === 0) {
                console.warn("No episodes data, cannot save full history item.");
            }
            if (!currentVideoTitle) return; // Need title

            const urlParams = new URLSearchParams(window.location.search);
            const sourceName = urlParams.get('source') || localStorage.getItem('lastPlayedSource') || ''; // Try to get source

            let currentPosition = 0;
            let videoDuration = 0;
            if (dp && dp.video) {
                currentPosition = dp.video.currentTime;
                videoDuration = dp.video.duration;
            }

            const videoInfo = {
                title: currentVideoTitle,
                url: window.location.href, // Save the full URL to restore state
                episodeIndex: currentEpisodeIndex,
                sourceName: sourceName,
                timestamp: Date.now(),
                playbackPosition: currentPosition > 5 ? currentPosition : 0, // Save if > 5s
                duration: videoDuration || 0,
                episodes: currentEpisodes ? [...currentEpisodes] : [] // Deep copy episodes
            };

            // Use global function if available (from ui.js), otherwise local implementation
            if (typeof window.parent.addToViewingHistory === 'function') {
                 // If in an iframe, try calling parent. Be careful with cross-origin.
                 try { window.parent.addToViewingHistory(videoInfo); } catch(e) { console.warn("Cannot call parent addToViewingHistory"); saveToHistoryLocal(videoInfo); }
            } else if (typeof addToViewingHistory === 'function') {
                 addToViewingHistory(videoInfo);
            } else {
                 saveToHistoryLocal(videoInfo); // Fallback to local storage logic
            }
             // Store last played source for potential reuse
             if(sourceName) localStorage.setItem('lastPlayedSource', sourceName);
        }

        // Local fallback for saving history (simplified)
        function saveToHistoryLocal(videoInfo) {
            try {
                let history = JSON.parse(localStorage.getItem(VIEWING_HISTORY_KEY) || '[]'); // Use constant
                const existingIndex = history.findIndex(item => item.title === videoInfo.title); // Simple match by title

                if (existingIndex !== -1) {
                    // Update existing item
                    const updatedItem = { ...history[existingIndex], ...videoInfo }; // Merge, overwriting timestamp etc.
                    history.splice(existingIndex, 1);
                    history.unshift(updatedItem);
                } else {
                    history.unshift(videoInfo);
                }

                // Limit history size
                if (history.length > (window.MAX_VIEWING_HISTORY_ITEMS || 50)) {
                    history = history.slice(0, window.MAX_VIEWING_HISTORY_ITEMS || 50);
                }
                localStorage.setItem(VIEWING_HISTORY_KEY, JSON.stringify(history));
                console.log(`Saved/Updated history for "${videoInfo.title}" locally.`);
            } catch (e) {
                console.error("Failed to save viewing history locally:", e);
            }
        }

        function startProgressSaveInterval() {
            clearInterval(progressSaveInterval); // Clear existing timer
            progressSaveInterval = setInterval(saveCurrentProgress, 15000); // Save every 15s
            console.log("Started progress save interval.");
        }

        // Save progress - optionally mark as finished
        function saveCurrentProgress(markFinished = false) {
            if (!dp || !dp.video || !currentVideoTitle) return;
            const currentTime = dp.video.currentTime;
            const duration = dp.video.duration;

             // Don't save if duration is invalid or playback hasn't started meaningfully
             if (!duration || isNaN(duration) || duration <= 0 || currentTime < 1) return;

            const progressKey = `videoProgress_${getVideoId()}`;
            let progressData = {
                position: markFinished ? 0 : currentTime, // Reset position if finished
                duration: duration,
                timestamp: Date.now(),
                 finished: markFinished // Add finished flag
            };

            try {
                // Also update the main viewing history item if possible
                let history = JSON.parse(localStorage.getItem(VIEWING_HISTORY_KEY) || '[]');
                const historyIndex = history.findIndex(item => item.title === currentVideoTitle); // Find by title

                if (historyIndex !== -1) {
                    history[historyIndex].playbackPosition = progressData.position;
                    history[historyIndex].duration = progressData.duration;
                    history[historyIndex].timestamp = progressData.timestamp;
                     history[historyIndex].finished = markFinished; // Update finished state
                    // Ensure the correct episode index is stored
                    history[historyIndex].episodeIndex = currentEpisodeIndex;
                    // Update the URL in history to reflect the current state
                    history[historyIndex].url = window.location.href;
                    localStorage.setItem(VIEWING_HISTORY_KEY, JSON.stringify(history));
                }
                // Save specific progress key as well (might be redundant but safe)
                localStorage.setItem(progressKey, JSON.stringify(progressData));
                 // console.log(`Progress saved: ${currentTime.toFixed(1)}s / ${duration.toFixed(1)}s ${markFinished ? '(Finished)' : ''}`);
            } catch (e) {
                console.error("Failed to save progress:", e);
            }
        }

        function clearVideoProgress() {
            const progressKey = `videoProgress_${getVideoId()}`;
            try {
                localStorage.removeItem(progressKey);
                console.log(`Cleared progress key: ${progressKey}`);
            } catch (e) {
                console.error("Failed to clear video progress:", e);
            }
        }

        function getVideoId() {
            // Use title and source name (if available) for better uniqueness
             const urlParams = new URLSearchParams(window.location.search);
             const source = urlParams.get('source') || '';
            return `${encodeURIComponent(currentVideoTitle)}_${encodeURIComponent(source || 'unknown')}`;
        }

        // --- Utilities ---
        function formatTime(seconds) {
            if (isNaN(seconds) || seconds < 0) return '00:00';
            seconds = Math.floor(seconds);
            const minutes = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }

        function showToast(message, type = 'info') { // Default to info
             if (dp && dp.notice) {
                 // Use DPlayer's notice for integrated feel
                 dp.notice(message, 2000, type === 'error' ? 0.8 : 0.7); // Opacity based on type?
             } else {
                 // Fallback simple toast (if needed)
                 console.log(`[Toast-${type}]: ${message}`);
                 // Implement simple DOM toast if required and DPlayer unavailable
             }
        }

         function showShortcutHint(text, direction) {
            if (!shortcutHintElement || !shortcutTextElement || !shortcutIconElement) return;

            clearTimeout(shortcutHintTimeout);

            shortcutTextElement.textContent = text;
            // Update icon based on direction (simple example)
             if (direction === 'left') {
                shortcutIconElement.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>';
            } else if (direction === 'right') {
                shortcutIconElement.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>';
            } // Add more icons as needed

            shortcutHintElement.classList.add('show');
            shortcutHintElement.setAttribute('aria-hidden', 'false');

            shortcutHintTimeout = setTimeout(() => {
                shortcutHintElement.classList.remove('show');
                 shortcutHintElement.setAttribute('aria-hidden', 'true');
            }, 1500); // Shorter duration for shortcuts
        }

        function toggleControlsLock() {
            if (!playerContainerElement || !lockToggleButtonElement || !lockIconElement) return;
            controlsLocked = !controlsLocked;
            playerContainerElement.classList.toggle('controls-locked', controlsLocked);

            const lockLabel = controlsLocked ? "解锁控制" : "锁定控制";
            lockToggleButtonElement.title = lockLabel;
            lockToggleButtonElement.setAttribute('aria-label', lockLabel);

            lockIconElement.innerHTML = controlsLocked
                ? '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m0-8V7a4 4 0 00-8 0v2m8 0H4v8h16v-8h-4z"/>' // Locked Icon
                : '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11V7a3 3 0 00-6 0v4m-3 4h12v6H6v-6z"/>'; // Unlocked Icon

             showToast(controlsLocked ? '控制已锁定' : '控制已解锁', 'info');
        }

        // --- Custom HLS Loader for Ad Filtering ---
        class CustomHlsJsLoader extends Hls.DefaultConfig.loader {
            constructor(config) {
                super(config);
                const load = this.load.bind(this);
                this.load = function(context, config, callbacks) {
                    // Only intercept playlist requests
                    if (context.type === Hls.ContextType.MANIFEST || context.type === Hls.ContextType.LEVEL) {
                        const originalOnSuccess = callbacks.onSuccess;
                        callbacks.onSuccess = function(response, stats, context) {
                            if (response.data && typeof response.data === 'string') {
                                // Basic filtering: remove discontinuity tags
                                response.data = response.data.split('\n').filter(line => !line.includes('#EXT-X-DISCONTINUITY')).join('\n');
                                // console.log("Filtered M3U8 playlist.");
                            }
                            // Call original success handler
                            originalOnSuccess(response, stats, context);
                        };
                    }
                    // Proceed with original load request
                    load(context, config, callbacks);
                };
            }
        }

    </script>
</body>
</html>
